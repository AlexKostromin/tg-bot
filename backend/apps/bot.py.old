import os
import django

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
django.setup()

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application, CommandHandler, MessageHandler, CallbackQueryHandler, 
    ConversationHandler, ContextTypes, filters
)
from asgiref.sync import sync_to_async
from apps.users.models import User, ProfileChangeLog
from apps.competitions.models import Competition
from django.core.mail import send_mail
from django.conf import settings
import logging

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Conversation states
# Ð’ÐÐ–ÐÐž: Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ð¹ ConversationHandler Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð±Ñ‹Ñ‚ÑŒ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¼Ð¸.
(
    START,
    CONTACT_MESSAGE,
    COMPETITION_SELECT,
    ROLE_SELECT,
    CONFIRM_DATA,
    EDIT_FIELD,
    EDIT_CHOICE,
    MORE_EDITS,
    NEW_USER_NAME,
    NEW_USER_SURNAME,
    NEW_USER_PHONE,
    NEW_USER_EMAIL,
    NEW_USER_COUNTRY,
    NEW_USER_CITY,
    NEW_USER_SCHOOL,
    NEW_USER_CERT_ROLE,
    NEW_USER_CERT_NAME,
    NEW_USER_COMPANY,
    NEW_USER_POSITION,
    NEW_USER_IMPORTANT,
) = range(20)

# Sync-to-async wrappers for Django ORM
@sync_to_async
def get_or_create_user(chat_id, telegram_id, username, first_name, last_name):
    """Get or create user from chat_id"""
    db_user, created = User.objects.get_or_create(
        chat_id=chat_id,
        defaults={
            'telegram_id': telegram_id,
            'username': username or '',
            'first_name': first_name or '',
            'last_name': last_name or '',
        }
    )
    if not created:
        db_user.telegram_id = telegram_id
        db_user.username = username or ''
        db_user.first_name = first_name or ''
        db_user.last_name = last_name or ''
        db_user.save()
    return db_user

@sync_to_async
def get_competitions():
    """Get all competitions"""
    return list(Competition.objects.all())

@sync_to_async
def get_competition_by_id(comp_id):
    """Get competition by ID"""
    return Competition.objects.get(id=comp_id)

@sync_to_async
def get_user_by_telegram_id(telegram_id):
    """Get user by telegram_id or raise DoesNotExist"""
    return User.objects.get(telegram_id=telegram_id)

@sync_to_async
def add_user_to_competition(user, comp, role):
    """Add user to competition's role list"""
    if role == 'player':
        comp.arbitrators.add(user)
    elif role == 'voter':
        comp.voters.add(user)
    elif role == 'viewer':
        comp.viewers.add(user)
    elif role == 'adviser':
        comp.advisers.add(user)

@sync_to_async
def update_or_create_new_user(chat_id, telegram_id, first_name, last_name, phone, email, country, city, school, company, position, certificate_name, important_info):
    """Update existing user created in start() with full profile data"""
    user = User.objects.get(chat_id=chat_id)
    user.telegram_id = telegram_id
    user.first_name = first_name
    user.last_name = last_name
    user.phone = phone
    user.email = email
    user.country = country
    user.city = city
    user.school = school
    user.company = company
    user.position = position
    user.certificate_name = certificate_name
    user.important_info = important_info
    user.save()
    return user

@sync_to_async
def create_profile_log(user, field_name, old_value, new_value):
    """Create profile change log"""
    return ProfileChangeLog.objects.create(
        user=user,
        field_name=field_name,
        old_value=old_value,
        new_value=new_value
    )

@sync_to_async
def update_user_fields(user, **kwargs):
    """Update user fields and save"""
    for key, value in kwargs.items():
        setattr(user, key, value)
    user.save()
    return user


@sync_to_async
def send_contact_email(subject, message, from_email, recipient_list):
    """Send contact email using Django's send_mail"""
    return send_mail(subject, message, from_email, recipient_list, fail_silently=False)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Start command - show main menu"""
    user = update.effective_user
    chat_id = str(update.effective_chat.id)
    
    # Save/update basic user info
    await get_or_create_user(
        chat_id=chat_id,
        telegram_id=str(user.id),
        username=user.username,
        first_name=user.first_name,
        last_name=user.last_name,
    )
    
    keyboard = [
        [InlineKeyboardButton("ðŸ’¬ Ð¡Ð²ÑÐ·Ð°Ñ‚ÑŒÑÑ Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹ USN", callback_data='contact_usn')],
        [InlineKeyboardButton("âš½ Ð—Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒÑÑ Ð½Ð° ÑÐ¾Ñ€ÐµÐ²Ð½Ð¾Ð²Ð°Ð½Ð¸Ñ", callback_data='register_competition')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    message_text = "Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ! ðŸ‘‹\n\nÐ’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ:"
    
    # Handle both message (/start) and callback query cases
    if update.message:
        await update.message.reply_text(message_text, reply_markup=reply_markup)
    elif update.callback_query:
        query = update.callback_query
        await query.answer()
        await query.edit_message_text(text=message_text, reply_markup=reply_markup)
    
    return START


async def button_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle main menu buttons"""
    query = update.callback_query
    await query.answer()
    
    if query.data == 'contact_usn':
        await query.edit_message_text(
            text="ðŸ“ž Ð¡Ð²ÑÐ¶Ð¸Ñ‚ÐµÑÑŒ Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹ USN\n\nÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ð²Ð°ÑˆÐµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ:"
        )
        return CONTACT_MESSAGE
    
    elif query.data == 'register_competition':
        context.user_data['telegram_id'] = str(update.effective_user.id)
        context.user_data['chat_id'] = str(update.effective_chat.id)
        return await show_competitions(update, context)


async def contact_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle contact message"""
    message_text = update.message.text
    user = update.effective_user
    chat_id = str(update.effective_chat.id) if update.effective_chat else 'unknown'
    
    logger.info(f"Message from {user.username} ({user.id}): {message_text}")
    # Forward message to contact email
    subject = f"USN contact message from @{user.username or user.id}"
    body = f"From: @{user.username or 'â€”'} (id: {user.id}, chat_id: {chat_id})\n\n{message_text}"
    from_email = getattr(settings, 'DEFAULT_FROM_EMAIL', 'no-reply@localhost')
    try:
        await send_contact_email(subject, body, from_email, ['krouzi@mail.ru'])
    except Exception as exc:
        logger.exception('Failed to send contact email: %s', exc)

    await update.message.reply_text(
        "Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾ Ð·Ð° Ð²Ð°ÑˆÐµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ! ðŸ“§\n"
        "ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° USN ÑÐ²ÑÐ¶ÐµÑ‚ÑÑ Ñ Ð²Ð°Ð¼Ð¸ Ð² Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑˆÐµÐµ Ð²Ñ€ÐµÐ¼Ñ."
    )
    
    return await start(update, context)


async def show_competitions(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Show available competitions"""
    query = update.callback_query if update.callback_query else None
    
    competitions = await get_competitions()
    
    if not competitions:
        text = "âŒ Ð¡ÐµÐ¹Ñ‡Ð°Ñ Ð½ÐµÑ‚ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ñ… ÑÐ¾Ñ€ÐµÐ²Ð½Ð¾Ð²Ð°Ð½Ð¸Ð¹ Ð´Ð»Ñ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸.\n\nÐ•ÑÐ»Ð¸ Ñƒ Ð²Ð°Ñ Ð¾ÑÑ‚Ð°Ð»Ð¸ÑÑŒ Ð²Ð¾Ð¿Ñ€Ð¾ÑÑ‹ - ÑÐ²ÑÐ¶Ð¸Ñ‚ÐµÑÑŒ Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹ USN"
        if query:
            await query.edit_message_text(text=text)
        else:
            await update.message.reply_text(text)
        return await start(update, context)
    
    if len(competitions) == 1:
        context.user_data['competition_id'] = competitions[0].id
        context.user_data['competition_name'] = competitions[0].name
        return await show_roles(update, context)
    
    keyboard = []
    for comp in competitions:
        keyboard.append([InlineKeyboardButton(comp.name, callback_data=f'comp_{comp.id}')])
    
    keyboard.append([InlineKeyboardButton("âŒ ÐžÑ‚Ð¼ÐµÐ½Ð°", callback_data='cancel')])
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    text = "âš½ Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÐ¾Ñ€ÐµÐ²Ð½Ð¾Ð²Ð°Ð½Ð¸Ðµ - Ð±ÑƒÐ´ÐµÐ¼ Ñ€Ð°Ð´Ñ‹ Ð²Ð¸Ð´ÐµÑ‚ÑŒ Ð²Ð°Ñ ÑÑ€ÐµÐ´Ð¸ ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ¾Ð²!"
    if query:
        await query.edit_message_text(text=text, reply_markup=reply_markup)
    else:
        await update.message.reply_text(text, reply_markup=reply_markup)
    
    return COMPETITION_SELECT


async def select_competition(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle competition selection"""
    query = update.callback_query
    await query.answer()
    
    if query.data == 'cancel':
        return await start(update, context)
    
    comp_id = int(query.data.split('_')[1])
    comp = await get_competition_by_id(comp_id)
    
    context.user_data['competition_id'] = comp.id
    context.user_data['competition_name'] = comp.name
    
    return await show_roles(update, context)


async def show_roles(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Show available roles for competition"""
    query = update.callback_query if update.callback_query else None
    
    comp_id = context.user_data.get('competition_id')
    comp = await get_competition_by_id(comp_id)
    
    available_roles = [
        ('player', 'Ð˜Ð³Ñ€Ð¾Ðº'),
        ('voter', 'Ð¡ÑƒÐ´ÑŒÑ'),
        ('viewer', 'Ð—Ñ€Ð¸Ñ‚ÐµÐ»ÑŒ'),
        ('adviser', 'Ð¡ÐµÐºÑƒÐ½Ð´Ð°Ð½Ñ‚'),
    ]
    
    keyboard = []
    for role_key, role_name in available_roles:
        keyboard.append([InlineKeyboardButton(role_name, callback_data=f'role_{role_key}')])
    
    keyboard.append([InlineKeyboardButton("âŒ ÐžÑ‚Ð¼ÐµÐ½Ð°", callback_data='cancel')])
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    text = "Ð’ ÐºÐ°ÐºÐ¾Ð¹ Ñ€Ð¾Ð»Ð¸ Ð²Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¸ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸Ñ‚ÑŒÑÑ?"
    if query:
        await query.edit_message_text(text=text, reply_markup=reply_markup)
    else:
        await update.message.reply_text(text, reply_markup=reply_markup)
    
    return ROLE_SELECT


async def select_role(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle role selection"""
    query = update.callback_query
    await query.answer()
    
    if query.data == 'cancel':
        return await start(update, context)
    
    role = query.data.split('_')[1]
    context.user_data['role'] = role
    
    telegram_id = context.user_data.get('telegram_id')
    
    try:
        user = await get_user_by_telegram_id(telegram_id)
        return await confirm_existing_user(update, context, user, role)
    except User.DoesNotExist:
        return await register_new_user_start(update, context)


async def confirm_existing_user(update: Update, context: ContextTypes.DEFAULT_TYPE, user: User, role: str) -> int:
    """Show existing user data for confirmation"""
    query = update.callback_query
    
    cert_info = f"Ð˜Ð¼Ñ Ð¸ Ñ„Ð°Ð¼Ð¸Ð»Ð¸Ñ Ð´Ð»Ñ ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð°: {user.certificate_name or 'â€”'}"
    if role not in ['player', 'voter']:
        cert_info = ""
    
    text = (
        f"Ð”Ð¾Ð±Ñ€Ñ‹Ð¹ Ð´ÐµÐ½ÑŒ, {user.first_name} {user.last_name}!\n"
        f"ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð²Ð°ÑˆÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð»Ñ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸:\n"
        f"Ð˜Ð¼Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Telegram: @{user.username or 'â€”'}\n"
        f"Ð¢ÐµÐ»ÐµÑ„Ð¾Ð½: {user.phone or 'â€”'}\n"
        f"Email: {user.email or 'â€”'}\n"
        f"Ð¡Ñ‚Ñ€Ð°Ð½Ð°: {user.country or 'â€”'}\n"
        f"Ð“Ð¾Ñ€Ð¾Ð´: {user.city or 'â€”'}\n"
        f"ÐšÐ»ÑƒÐ±/ÑˆÐºÐ¾Ð»Ð°: {user.school or 'â€”'}\n"
        f"{cert_info}\n"
        f"ÐšÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ñ: {user.company or 'â€”'}\n"
        f"Ð”Ð¾Ð»Ð¶Ð½Ð¾ÑÑ‚ÑŒ: {user.position or 'â€”'}\n"
        f"ÐšÐ°Ðº Ð²Ð°Ñ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ð½Ð° ÑÐ¾Ñ€ÐµÐ²Ð½Ð¾Ð²Ð°Ð½Ð¸ÑÑ…: {user.important_info or 'â€”'}"
    )
    
    keyboard = [
        [InlineKeyboardButton("âœ… Ð”Ð°", callback_data='confirm_yes')],
        [InlineKeyboardButton("âŒ ÐÐµÑ‚", callback_data='confirm_no')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text=text, reply_markup=reply_markup)
    return CONFIRM_DATA


async def confirm_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle confirmation choice"""
    query = update.callback_query
    await query.answer()
    
    if query.data == 'confirm_yes':
        telegram_id = context.user_data.get('telegram_id')
        user = await get_user_by_telegram_id(telegram_id)
        role = context.user_data.get('role')
        comp_id = context.user_data.get('competition_id')
        comp_name = context.user_data.get('competition_name')
        
        comp = await get_competition_by_id(comp_id)
        await add_user_to_competition(user, comp, role)
        
        role_labels = {'player': 'Ð˜Ð³Ñ€Ð¾Ðº', 'voter': 'Ð¡ÑƒÐ´ÑŒÑ', 'viewer': 'Ð—Ñ€Ð¸Ñ‚ÐµÐ»ÑŒ', 'adviser': 'Ð¡ÐµÐºÑƒÐ½Ð´Ð°Ð½Ñ‚'}
        
        text = f"âœ… ÐžÑ‚Ð»Ð¸Ñ‡Ð½Ð¾! Ð’Ñ‹ Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ñ‹ ÐºÐ°Ðº {role_labels.get(role)} Ð½Ð° {comp_name}."
        await query.edit_message_text(text=text)
        
        return await start(update, context)
    
    else:
        return await show_edit_options(update, context)


async def show_edit_options(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Show which fields can be edited"""
    query = update.callback_query
    
    keyboard = [
        [InlineKeyboardButton("Ð˜Ð¼Ñ Ð¸ Ñ„Ð°Ð¼Ð¸Ð»Ð¸Ñ", callback_data='edit_name')],
        [InlineKeyboardButton("Ð¢ÐµÐ»ÐµÑ„Ð¾Ð½", callback_data='edit_phone')],
        [InlineKeyboardButton("Email", callback_data='edit_email')],
        [InlineKeyboardButton("Ð“Ð¾Ñ€Ð¾Ð´", callback_data='edit_city')],
        [InlineKeyboardButton("ÐšÐ»ÑƒÐ±/ÑˆÐºÐ¾Ð»Ð°", callback_data='edit_school')],
        [InlineKeyboardButton("Ð˜Ð¼Ñ Ð¸ Ñ„Ð°Ð¼Ð¸Ð»Ð¸Ñ Ð´Ð»Ñ ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð°", callback_data='edit_certificate')],
        [InlineKeyboardButton("ÐšÐ°Ðº Ð²Ð°Ñ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ð½Ð° ÑÐ¾Ñ€ÐµÐ²Ð½Ð¾Ð²Ð°Ð½Ð¸ÑÑ…", callback_data='edit_important')],
        [InlineKeyboardButton("âŒ ÐžÑ‚Ð¼ÐµÐ½Ð°", callback_data='cancel')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    text = "ÐšÐ°ÐºÐ¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð²Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ?"
    await query.edit_message_text(text=text, reply_markup=reply_markup)
    
    return EDIT_FIELD


async def edit_field(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle field editing"""
    query = update.callback_query
    await query.answer()
    
    if query.data == 'cancel':
        return await start(update, context)
    
    field = query.data.split('_')[1]
    context.user_data['edit_field'] = field
    
    field_prompts = {
        'name': "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°ÑˆÐµ Ð¸Ð¼Ñ Ð¸ Ñ„Ð°Ð¼Ð¸Ð»Ð¸ÑŽ:",
        'phone': "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½:",
        'email': "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ email:",
        'city': "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ Ð³Ð¾Ñ€Ð¾Ð´:",
        'school': "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑˆÐºÐ¾Ð»Ñƒ/ÐºÐ»ÑƒÐ±:",
        'certificate': "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¸Ð¼Ñ Ð¸ Ñ„Ð°Ð¼Ð¸Ð»Ð¸ÑŽ Ð´Ð»Ñ ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð° (Ð»Ð°Ñ‚Ð¸Ð½Ð¸Ñ†ÐµÐ¹):",
        'important': "ÐšÐ°Ðº Ð²Ð°Ñ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ð½Ð° ÑÐ¾Ñ€ÐµÐ²Ð½Ð¾Ð²Ð°Ð½Ð¸ÑÑ…?"
    }
    
    await query.edit_message_text(text=field_prompts.get(field))
    return EDIT_CHOICE


async def edit_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle edited field input"""
    field = context.user_data.get('edit_field')
    new_value = update.message.text
    telegram_id = context.user_data.get('telegram_id')
    user = await get_user_by_telegram_id(telegram_id)
    
    field_mapping = {
        'phone': 'phone',
        'email': 'email',
        'city': 'city',
        'school': 'school',
        'certificate': 'certificate_name',
        'important': 'important_info'
    }
    
    if field == 'name':
        parts = new_value.split(maxsplit=1)
        old_first = user.first_name
        old_last = user.last_name
        new_first = parts[0] if parts else ''
        new_last = parts[1] if len(parts) > 1 else ''
        
        await update_user_fields(user, first_name=new_first, last_name=new_last)
        
        await create_profile_log(user, 'first_name', old_first, new_first)
        if len(parts) > 1:
            await create_profile_log(user, 'last_name', old_last, new_last)
    else:
        db_field = field_mapping.get(field)
        if db_field:
            old_value = getattr(user, db_field, None)
            await update_user_fields(user, **{db_field: new_value})
            
            if field == 'important':
                await create_profile_log(user, db_field, old_value, new_value)
    
    keyboard = [
        [InlineKeyboardButton("âœ… Ð”Ð°", callback_data='more_edits_yes')],
        [InlineKeyboardButton("âŒ ÐÐµÑ‚", callback_data='more_edits_no')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ñ‹! ðŸ“\n\nÐÑƒÐ¶Ð½Ð¾ Ð²Ð½ÐµÑÑ‚Ð¸ ÐµÑ‰Ñ‘ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ?",
        reply_markup=reply_markup
    )
    
    return MORE_EDITS


async def more_edits(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle more edits choice"""
    query = update.callback_query
    await query.answer()
    
    if query.data == 'more_edits_yes':
        return await show_edit_options(update, context)
    else:
        telegram_id = context.user_data.get('telegram_id')
        user = await get_user_by_telegram_id(telegram_id)
        role = context.user_data.get('role')
        return await confirm_existing_user(update, context, user, role)


async def register_new_user_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Start new user registration"""
    query = update.callback_query
    await query.edit_message_text(text="Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°ÑˆÐµ Ð¸Ð¼Ñ Ð² Ð¾Ñ‚Ð²ÐµÑ‚ Ð½Ð° ÑÑ‚Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ:")
    return NEW_USER_NAME


async def new_user_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['first_name'] = update.message.text
    await update.message.reply_text("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°ÑˆÑƒ Ñ„Ð°Ð¼Ð¸Ð»Ð¸ÑŽ:")
    return NEW_USER_SURNAME


async def new_user_surname(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['last_name'] = update.message.text
    await update.message.reply_text("Ð£ÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½:")
    return NEW_USER_PHONE


async def new_user_phone(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['phone'] = update.message.text
    await update.message.reply_text("Ð£ÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ email:")
    return NEW_USER_EMAIL


async def new_user_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['email'] = update.message.text
    await update.message.reply_text("Ð Ð°ÑÑÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð² ÐºÐ°ÐºÐ¾Ð¹ ÑÑ‚Ñ€Ð°Ð½Ðµ Ð²Ñ‹ Ð¶Ð¸Ð²ÐµÑ‚Ðµ:")
    return NEW_USER_COUNTRY


async def new_user_country(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['country'] = update.message.text
    await update.message.reply_text("Ð£Ñ‚Ð¾Ñ‡Ð½Ð¸Ñ‚Ðµ Ð³Ð¾Ñ€Ð¾Ð´ Ð²Ð°ÑˆÐµÐ³Ð¾ Ð¿Ñ€Ð¾Ð¶Ð¸Ð²Ð°Ð½Ð¸Ñ:")
    return NEW_USER_CITY


async def new_user_city(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['city'] = update.message.text
    await update.message.reply_text("Ð£ÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð¨ÐºÐ¾Ð»Ñƒ/ÐšÐ»ÑƒÐ±, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð²Ñ‹ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚Ðµ:")
    return NEW_USER_SCHOOL


async def new_user_school(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['school'] = update.message.text
    
    role = context.user_data.get('role')
    
    if role in ['player', 'voter']:
        keyboard = [[InlineKeyboardButton("âœ… Ð”Ð°", callback_data='cert_yes')], 
                   [InlineKeyboardButton("âŒ ÐÐµÑ‚", callback_data='cert_no')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "Ð ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ñ Ð½Ð° Ñ€Ð¾Ð»ÑŒ Player/Voter?",
            reply_markup=reply_markup
        )
        return NEW_USER_CERT_ROLE
    else:
        await update.message.reply_text("Ð Ð°ÑÑÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð² ÐºÐ°ÐºÐ¾Ð¹ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸ Ð²Ñ‹ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚Ðµ:")
        return NEW_USER_COMPANY


async def new_user_cert_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    if query.data == 'cert_yes':
        await query.edit_message_text("ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ð»Ð°Ñ‚Ð¸Ð½Ð¸Ñ†ÐµÐ¹ Ð˜Ð¼Ñ Ð¸ Ð¤Ð°Ð¼Ð¸Ð»Ð¸ÑŽ Ð´Ð»Ñ ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð°:")
        return NEW_USER_CERT_NAME
    else:
        await query.edit_message_text("Ð Ð°ÑÑÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð² ÐºÐ°ÐºÐ¾Ð¹ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸ Ð²Ñ‹ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚Ðµ:")
        return NEW_USER_COMPANY


async def new_user_cert_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['certificate_name'] = update.message.text
    await update.message.reply_text("Ð Ð°ÑÑÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð² ÐºÐ°ÐºÐ¾Ð¹ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸ Ð²Ñ‹ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚Ðµ:")
    return NEW_USER_COMPANY


async def new_user_company(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['company'] = update.message.text
    await update.message.reply_text("Ð£Ñ‚Ð¾Ñ‡Ð½Ð¸Ñ‚Ðµ Ð²Ð°ÑˆÑƒ Ð´Ð¾Ð»Ð¶Ð½Ð¾ÑÑ‚ÑŒ:")
    return NEW_USER_POSITION


async def new_user_position(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['position'] = update.message.text
    
    role = context.user_data.get('role')
    if role in ['player', 'voter']:
        await update.message.reply_text("ÐŸÐ¾Ð´ÑÐºÐ°Ð¶Ð¸Ñ‚Ðµ, ÐºÐ°Ðº Ð²Ð°Ñ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ð½Ð° ÑÐ¾Ñ€ÐµÐ²Ð½Ð¾Ð²Ð°Ð½Ð¸ÑÑ…?")
        return NEW_USER_IMPORTANT
    else:
        return await finalize_new_user(update, context)


async def new_user_important(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['important_info'] = update.message.text
    return await finalize_new_user(update, context)


async def finalize_new_user(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    chat_id = context.user_data.get('chat_id')
    telegram_id = context.user_data.get('telegram_id')
    
    # Get or update existing user (already created in start())
    user = await update_or_create_new_user(
        chat_id=chat_id,
        telegram_id=telegram_id,
        first_name=context.user_data.get('first_name'),
        last_name=context.user_data.get('last_name'),
        phone=context.user_data.get('phone'),
        email=context.user_data.get('email'),
        country=context.user_data.get('country'),
        city=context.user_data.get('city'),
        school=context.user_data.get('school'),
        company=context.user_data.get('company'),
        position=context.user_data.get('position'),
        certificate_name=context.user_data.get('certificate_name'),
        important_info=context.user_data.get('important_info'),
    )
    
    role = context.user_data.get('role')
    comp_id = context.user_data.get('competition_id')
    comp_name = context.user_data.get('competition_name')
    comp = await get_competition_by_id(comp_id)
    
    await add_user_to_competition(user, comp, role)
    
    role_labels = {'player': 'Ð˜Ð³Ñ€Ð¾Ðº', 'voter': 'Ð¡ÑƒÐ´ÑŒÑ', 'viewer': 'Ð—Ñ€Ð¸Ñ‚ÐµÐ»ÑŒ', 'adviser': 'Ð¡ÐµÐºÑƒÐ½Ð´Ð°Ð½Ñ‚'}
    
    text = (
        f"âœ… ÐžÑ‚Ð»Ð¸Ñ‡Ð½Ð¾! Ð’Ñ‹ Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ñ‹ ÐºÐ°Ðº {role_labels.get(role)} Ð½Ð° {comp_name}.\n\n"
        f"Ð’Ð°ÑˆÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ðµ:\n"
        f"Ð˜Ð¼Ñ: {user.first_name} {user.last_name}\n"
        f"Ð¢ÐµÐ»ÐµÑ„Ð¾Ð½: {user.phone}\n"
        f"Email: {user.email}\n"
        f"Ð¡Ñ‚Ñ€Ð°Ð½Ð°: {user.country}\n"
        f"Ð“Ð¾Ñ€Ð¾Ð´: {user.city}"
    )
    
    await update.message.reply_text(text)
    return await start(update, context)


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("ÐžÐ¿ÐµÑ€Ð°Ñ†Ð¸Ñ Ð¾Ñ‚Ð¼ÐµÐ½ÐµÐ½Ð°.")
    return await start(update, context)


def setup_bot_handlers(app: Application) -> None:
    """Setup all bot handlers with conversation"""
    
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            START: [
                CallbackQueryHandler(button_start, pattern='^(contact_usn|register_competition)$'),
            ],
            CONTACT_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, contact_message),
            ],
            COMPETITION_SELECT: [
                CallbackQueryHandler(select_competition, pattern=r'^(comp_\d+|cancel)$'),
            ],
            ROLE_SELECT: [
                CallbackQueryHandler(select_role, pattern=r'^(role_(player|voter|viewer|adviser)|cancel)$'),
            ],
            CONFIRM_DATA: [
                CallbackQueryHandler(confirm_choice, pattern='^(confirm_yes|confirm_no)$'),
            ],
            EDIT_FIELD: [
                CallbackQueryHandler(edit_field, pattern=r'^(edit_(name|phone|email|city|school|certificate|important)|cancel)$'),
            ],
            EDIT_CHOICE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, edit_input),
            ],
            MORE_EDITS: [
                CallbackQueryHandler(more_edits, pattern='^more_edits_(yes|no)$'),
            ],
            NEW_USER_NAME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_name),
            ],
            NEW_USER_SURNAME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_surname),
            ],
            NEW_USER_PHONE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_phone),
            ],
            NEW_USER_EMAIL: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_email),
            ],
            NEW_USER_COUNTRY: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_country),
            ],
            NEW_USER_CITY: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_city),
            ],
            NEW_USER_SCHOOL: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_school),
            ],
            NEW_USER_CERT_ROLE: [
                CallbackQueryHandler(new_user_cert_choice, pattern='^cert_(yes|no)$'),
            ],
            NEW_USER_CERT_NAME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_cert_name),
            ],
            NEW_USER_COMPANY: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_company),
            ],
            NEW_USER_POSITION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_position),
            ],
            NEW_USER_IMPORTANT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_user_important),
            ],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )
    
    app.add_handler(conv_handler)
